<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DbUtils</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.dbutils</a> &gt; <span class="el_source">BeanProcessor.java</span></div><h1>BeanProcessor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.dbutils;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * &lt;p&gt;
 * &lt;code&gt;BeanProcessor&lt;/code&gt; matches column names to bean property names 
 * and converts &lt;code&gt;ResultSet&lt;/code&gt; columns into objects for those bean 
 * properties.  Subclasses should override the methods in the processing chain
 * to customize behavior.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 * 
 * @see BasicRowProcessor
 * 
 * @since DbUtils 1.1
 */
public class BeanProcessor {
    
    /**
     * Special array value used by &lt;code&gt;mapColumnsToProperties&lt;/code&gt; that 
     * indicates there is no bean property that matches a column from a 
     * &lt;code&gt;ResultSet&lt;/code&gt;.
     */
    protected static final int PROPERTY_NOT_FOUND = -1;
    
    /**
     * Set a bean's primitive properties to these defaults when SQL NULL 
     * is returned.  These are the same as the defaults that ResultSet get* 
     * methods return in the event of a NULL column.
     */
<span class="fc" id="L65">    private static final Map primitiveDefaults = new HashMap();</span>

    static {
<span class="fc" id="L68">        primitiveDefaults.put(Integer.TYPE, new Integer(0));</span>
<span class="fc" id="L69">        primitiveDefaults.put(Short.TYPE, new Short((short) 0));</span>
<span class="fc" id="L70">        primitiveDefaults.put(Byte.TYPE, new Byte((byte) 0));</span>
<span class="fc" id="L71">        primitiveDefaults.put(Float.TYPE, new Float(0));</span>
<span class="fc" id="L72">        primitiveDefaults.put(Double.TYPE, new Double(0));</span>
<span class="fc" id="L73">        primitiveDefaults.put(Long.TYPE, new Long(0));</span>
<span class="fc" id="L74">        primitiveDefaults.put(Boolean.TYPE, Boolean.FALSE);</span>
<span class="fc" id="L75">        primitiveDefaults.put(Character.TYPE, new Character('\u0000'));</span>
<span class="fc" id="L76">    }</span>

    /**
     * Constructor for BeanProcessor.
     */
    public BeanProcessor() {
<span class="fc" id="L82">        super();</span>
<span class="fc" id="L83">    }</span>
    
    /**
     * Convert a &lt;code&gt;ResultSet&lt;/code&gt; row into a JavaBean.  This 
     * implementation uses reflection and &lt;code&gt;BeanInfo&lt;/code&gt; classes to 
     * match column names to bean property names.  Properties are matched to 
     * columns based on several factors:
     * &lt;br/&gt;
     * &lt;ol&gt;
     *     &lt;li&gt;
     *     The class has a writable property with the same name as a column.
     *     The name comparison is case insensitive.
     *     &lt;/li&gt;
     * 
     *     &lt;li&gt;
     *     The column type can be converted to the property's set method 
     *     parameter type with a ResultSet.get* method.  If the conversion fails
     *     (ie. the property was an int and the column was a Timestamp) an
     *     SQLException is thrown.
     *     &lt;/li&gt;
     * &lt;/ol&gt;
     * 
     * &lt;p&gt;
     * Primitive bean properties are set to their defaults when SQL NULL is
     * returned from the &lt;code&gt;ResultSet&lt;/code&gt;.  Numeric fields are set to 0
     * and booleans are set to false.  Object bean properties are set to 
     * &lt;code&gt;null&lt;/code&gt; when SQL NULL is returned.  This is the same behavior
     * as the &lt;code&gt;ResultSet&lt;/code&gt; get* methods.
     * &lt;/p&gt;
     *
     * @param rs ResultSet that supplies the bean data
     * @param type Class from which to create the bean instance
     * @throws SQLException if a database access error occurs
     * @return the newly created bean
     */
    public Object toBean(ResultSet rs, Class type) throws SQLException {

<span class="fc" id="L120">        PropertyDescriptor[] props = this.propertyDescriptors(type);</span>

<span class="fc" id="L122">        ResultSetMetaData rsmd = rs.getMetaData();</span>
<span class="fc" id="L123">        int[] columnToProperty = this.mapColumnsToProperties(rsmd, props);</span>

<span class="fc" id="L125">        return this.createBean(rs, type, props, columnToProperty);</span>
    }
    
    /**
     * Convert a &lt;code&gt;ResultSet&lt;/code&gt; into a &lt;code&gt;List&lt;/code&gt; of JavaBeans.  
     * This implementation uses reflection and &lt;code&gt;BeanInfo&lt;/code&gt; classes to 
     * match column names to bean property names. Properties are matched to 
     * columns based on several factors:
     * &lt;br/&gt;
     * &lt;ol&gt;
     *     &lt;li&gt;
     *     The class has a writable property with the same name as a column.
     *     The name comparison is case insensitive.
     *     &lt;/li&gt;
     * 
     *     &lt;li&gt;
     *     The column type can be converted to the property's set method 
     *     parameter type with a ResultSet.get* method.  If the conversion fails
     *     (ie. the property was an int and the column was a Timestamp) an
     *     SQLException is thrown.
     *     &lt;/li&gt;
     * &lt;/ol&gt;
     * 
     * &lt;p&gt;
     * Primitive bean properties are set to their defaults when SQL NULL is
     * returned from the &lt;code&gt;ResultSet&lt;/code&gt;.  Numeric fields are set to 0
     * and booleans are set to false.  Object bean properties are set to 
     * &lt;code&gt;null&lt;/code&gt; when SQL NULL is returned.  This is the same behavior
     * as the &lt;code&gt;ResultSet&lt;/code&gt; get* methods.
     * &lt;/p&gt;
     *
     * @param rs ResultSet that supplies the bean data
     * @param type Class from which to create the bean instance
     * @throws SQLException if a database access error occurs
     * @return the newly created List of beans
     */
    public List toBeanList(ResultSet rs, Class type) throws SQLException {
<span class="fc" id="L162">        List results = new ArrayList();</span>

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (!rs.next()) {</span>
<span class="nc" id="L165">            return results;</span>
        }

<span class="fc" id="L168">        PropertyDescriptor[] props = this.propertyDescriptors(type);</span>
<span class="fc" id="L169">        ResultSetMetaData rsmd = rs.getMetaData();</span>
<span class="fc" id="L170">        int[] columnToProperty = this.mapColumnsToProperties(rsmd, props);</span>

        do {
<span class="fc" id="L173">            results.add(this.createBean(rs, type, props, columnToProperty));</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        } while (rs.next());</span>

<span class="fc" id="L176">        return results;</span>
    }
    
    /**
     * Creates a new object and initializes its fields from the ResultSet.
     *
     * @param rs The result set.
     * @param type The bean type (the return type of the object).
     * @param props The property descriptors.
     * @param columnToProperty The column indices in the result set.
     * @return An initialized object.
     * @throws SQLException if a database error occurs.
     */
    private Object createBean(ResultSet rs, Class type,
            PropertyDescriptor[] props, int[] columnToProperty)
            throws SQLException {

<span class="fc" id="L193">        Object bean = this.newInstance(type);</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (int i = 1; i &lt; columnToProperty.length; i++) {</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">            if (columnToProperty[i] == PROPERTY_NOT_FOUND) {</span>
<span class="fc" id="L198">                continue;</span>
            }
            
<span class="fc" id="L201">            PropertyDescriptor prop = props[columnToProperty[i]];</span>
<span class="fc" id="L202">            Class propType = prop.getPropertyType();</span>

<span class="fc" id="L204">            Object value = this.processColumn(rs, i, propType);</span>

<span class="pc bpc" id="L206" title="2 of 6 branches missed.">            if (propType != null &amp;&amp; value == null &amp;&amp; propType.isPrimitive()) {</span>
<span class="nc" id="L207">                value = primitiveDefaults.get(propType);</span>
            }

<span class="fc" id="L210">            this.callSetter(bean, prop, value);</span>
        }

<span class="fc" id="L213">        return bean;</span>
    }
    
    /**
     * Calls the setter method on the target object for the given property.
     * If no setter method exists for the property, this method does nothing.
     * @param target The object to set the property on.
     * @param prop The property to set.
     * @param value The value to pass into the setter.
     * @throws SQLException if an error occurs setting the property.
     */
    private void callSetter(Object target, PropertyDescriptor prop, Object value)
            throws SQLException {

<span class="fc" id="L227">        Method setter = prop.getWriteMethod();</span>

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (setter == null) {</span>
<span class="nc" id="L230">            return;</span>
        }

<span class="fc" id="L233">        Class[] params = setter.getParameterTypes();</span>
        try {
            // convert types for some popular ones
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (value != null) {</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                if (value instanceof java.util.Date) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                    if (params[0].getName().equals(&quot;java.sql.Date&quot;)) {</span>
<span class="nc" id="L239">                        value = new java.sql.Date(((java.util.Date) value).getTime());</span>
                    } else
<span class="nc bnc" id="L241" title="All 2 branches missed.">                    if (params[0].getName().equals(&quot;java.sql.Time&quot;)) {</span>
<span class="nc" id="L242">                        value = new java.sql.Time(((java.util.Date) value).getTime());</span>
                    } else
<span class="nc bnc" id="L244" title="All 2 branches missed.">                    if (params[0].getName().equals(&quot;java.sql.Timestamp&quot;)) {</span>
<span class="nc" id="L245">                        value = new java.sql.Timestamp(((java.util.Date) value).getTime());</span>
                    }
                }
            }

            // Don't call setter if the value object isn't the right type 
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (this.isCompatibleType(value, params[0])) {</span>
<span class="fc" id="L252">                setter.invoke(target, new Object[] { value });</span>
            } else {
<span class="nc" id="L254">              throw new SQLException(</span>
<span class="nc" id="L255">                  &quot;Cannot set &quot; + prop.getName() + &quot;: incompatible types.&quot;);</span>
            }

<span class="nc" id="L258">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L259">            throw new SQLException(</span>
<span class="nc" id="L260">                &quot;Cannot set &quot; + prop.getName() + &quot;: &quot; + e.getMessage());</span>

<span class="nc" id="L262">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L263">            throw new SQLException(</span>
<span class="nc" id="L264">                &quot;Cannot set &quot; + prop.getName() + &quot;: &quot; + e.getMessage());</span>

<span class="nc" id="L266">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L267">            throw new SQLException(</span>
<span class="nc" id="L268">                &quot;Cannot set &quot; + prop.getName() + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L269">        }</span>
<span class="fc" id="L270">    }</span>

    /**
     * ResultSet.getObject() returns an Integer object for an INT column.  The
     * setter method for the property might take an Integer or a primitive int.
     * This method returns true if the value can be successfully passed into
     * the setter method.  Remember, Method.invoke() handles the unwrapping
     * of Integer into an int.
     * 
     * @param value The value to be passed into the setter method.
     * @param type The setter's parameter type.
     * @return boolean True if the value is compatible.
     */
    private boolean isCompatibleType(Object value, Class type) {
        // Do object check first, then primitives
<span class="fc bfc" id="L285" title="All 4 branches covered.">        if (value == null || type.isInstance(value)) {</span>
<span class="fc" id="L286">            return true;</span>

<span class="fc" id="L288">        } else if (</span>
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">            type.equals(Integer.TYPE) &amp;&amp; Integer.class.isInstance(value)) {</span>
<span class="fc" id="L290">            return true;</span>

<span class="pc bpc" id="L292" title="3 of 4 branches missed.">        } else if (type.equals(Long.TYPE) &amp;&amp; Long.class.isInstance(value)) {</span>
<span class="nc" id="L293">            return true;</span>

<span class="fc" id="L295">        } else if (</span>
<span class="pc bpc" id="L296" title="2 of 4 branches missed.">            type.equals(Double.TYPE) &amp;&amp; Double.class.isInstance(value)) {</span>
<span class="fc" id="L297">            return true;</span>

<span class="nc bnc" id="L299" title="All 4 branches missed.">        } else if (type.equals(Float.TYPE) &amp;&amp; Float.class.isInstance(value)) {</span>
<span class="nc" id="L300">            return true;</span>

<span class="nc bnc" id="L302" title="All 4 branches missed.">        } else if (type.equals(Short.TYPE) &amp;&amp; Short.class.isInstance(value)) {</span>
<span class="nc" id="L303">            return true;</span>

<span class="nc bnc" id="L305" title="All 4 branches missed.">        } else if (type.equals(Byte.TYPE) &amp;&amp; Byte.class.isInstance(value)) {</span>
<span class="nc" id="L306">            return true;</span>

<span class="nc" id="L308">        } else if (</span>
<span class="nc bnc" id="L309" title="All 4 branches missed.">            type.equals(Character.TYPE) &amp;&amp; Character.class.isInstance(value)) {</span>
<span class="nc" id="L310">            return true;</span>

<span class="nc" id="L312">        } else if (</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">            type.equals(Boolean.TYPE) &amp;&amp; Boolean.class.isInstance(value)) {</span>
<span class="nc" id="L314">            return true;</span>

        } else {
<span class="nc" id="L317">            return false;</span>
        }

    }

    /**
     * Factory method that returns a new instance of the given Class.  This
     * is called at the start of the bean creation process and may be 
     * overridden to provide custom behavior like returning a cached bean
     * instance.
     *
     * @param c The Class to create an object from.
     * @return A newly created object of the Class.
     * @throws SQLException if creation failed.
     */
    protected Object newInstance(Class c) throws SQLException {
        try {
<span class="fc" id="L334">            return c.newInstance();</span>

<span class="nc" id="L336">        } catch (InstantiationException e) {</span>
<span class="nc" id="L337">            throw new SQLException(</span>
<span class="nc" id="L338">                &quot;Cannot create &quot; + c.getName() + &quot;: &quot; + e.getMessage());</span>

<span class="nc" id="L340">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L341">            throw new SQLException(</span>
<span class="nc" id="L342">                &quot;Cannot create &quot; + c.getName() + &quot;: &quot; + e.getMessage());</span>
        }
    }

    /**
     * Returns a PropertyDescriptor[] for the given Class.
     *
     * @param c The Class to retrieve PropertyDescriptors for.
     * @return A PropertyDescriptor[] describing the Class.
     * @throws SQLException if introspection failed.
     */
    private PropertyDescriptor[] propertyDescriptors(Class c)
        throws SQLException {
        // Introspector caches BeanInfo classes for better performance
<span class="fc" id="L356">        BeanInfo beanInfo = null;</span>
        try {
<span class="fc" id="L358">            beanInfo = Introspector.getBeanInfo(c);</span>

<span class="nc" id="L360">        } catch (IntrospectionException e) {</span>
<span class="nc" id="L361">            throw new SQLException(</span>
<span class="nc" id="L362">                &quot;Bean introspection failed: &quot; + e.getMessage());</span>
<span class="fc" id="L363">        }</span>

<span class="fc" id="L365">        return beanInfo.getPropertyDescriptors();</span>
    }
    
    /**
     * The positions in the returned array represent column numbers.  The 
     * values stored at each position represent the index in the 
     * &lt;code&gt;PropertyDescriptor[]&lt;/code&gt; for the bean property that matches 
     * the column name.  If no bean property was found for a column, the 
     * position is set to &lt;code&gt;PROPERTY_NOT_FOUND&lt;/code&gt;.
     * 
     * @param rsmd The &lt;code&gt;ResultSetMetaData&lt;/code&gt; containing column 
     * information.
     * 
     * @param props The bean property descriptors.
     * 
     * @throws SQLException if a database access error occurs
     *
     * @return An int[] with column index to property index mappings.  The 0th 
     * element is meaningless because JDBC column indexing starts at 1.
     */
    protected int[] mapColumnsToProperties(ResultSetMetaData rsmd,
            PropertyDescriptor[] props) throws SQLException {

<span class="fc" id="L388">        int cols = rsmd.getColumnCount();</span>
<span class="fc" id="L389">        int columnToProperty[] = new int[cols + 1];</span>
<span class="fc" id="L390">        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);</span>

<span class="fc bfc" id="L392" title="All 2 branches covered.">        for (int col = 1; col &lt;= cols; col++) {</span>
<span class="fc" id="L393">            String columnName = rsmd.getColumnName(col);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            for (int i = 0; i &lt; props.length; i++) {</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">                if (columnName.equalsIgnoreCase(props[i].getName())) {</span>
<span class="fc" id="L397">                    columnToProperty[col] = i;</span>
<span class="fc" id="L398">                    break;</span>
                }
            }
        }

<span class="fc" id="L403">        return columnToProperty;</span>
    }

    /**
     * Convert a &lt;code&gt;ResultSet&lt;/code&gt; column into an object.  Simple 
     * implementations could just call &lt;code&gt;rs.getObject(index)&lt;/code&gt; while
     * more complex implementations could perform type manipulation to match 
     * the column's type to the bean property type.
     * 
     * &lt;p&gt;
     * This implementation calls the appropriate &lt;code&gt;ResultSet&lt;/code&gt; getter 
     * method for the given property type to perform the type conversion.  If 
     * the property type doesn't match one of the supported 
     * &lt;code&gt;ResultSet&lt;/code&gt; types, &lt;code&gt;getObject&lt;/code&gt; is called.
     * &lt;/p&gt;
     * 
     * @param rs The &lt;code&gt;ResultSet&lt;/code&gt; currently being processed.  It is
     * positioned on a valid row before being passed into this method.
     * 
     * @param index The current column index being processed.
     * 
     * @param propType The bean property type that this column needs to be
     * converted into.
     * 
     * @throws SQLException if a database access error occurs
     * 
     * @return The object from the &lt;code&gt;ResultSet&lt;/code&gt; at the given column
     * index after optional type processing or &lt;code&gt;null&lt;/code&gt; if the column
     * value was SQL NULL.
     */
    protected Object processColumn(ResultSet rs, int index, Class propType)
        throws SQLException {

<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (propType.equals(String.class)) {</span>
<span class="fc" id="L437">            return rs.getString(index);</span>
            
<span class="fc" id="L439">        } else if (</span>
<span class="fc bfc" id="L440" title="All 4 branches covered.">            propType.equals(Integer.TYPE) || propType.equals(Integer.class)) {</span>
<span class="fc" id="L441">            return new Integer(rs.getInt(index));</span>

<span class="fc" id="L443">        } else if (</span>
<span class="pc bpc" id="L444" title="2 of 4 branches missed.">            propType.equals(Boolean.TYPE) || propType.equals(Boolean.class)) {</span>
<span class="nc" id="L445">            return new Boolean(rs.getBoolean(index));</span>

<span class="pc bpc" id="L447" title="2 of 4 branches missed.">        } else if (propType.equals(Long.TYPE) || propType.equals(Long.class)) {</span>
<span class="nc" id="L448">            return new Long(rs.getLong(index));</span>

<span class="fc" id="L450">        } else if (</span>
<span class="pc bpc" id="L451" title="1 of 4 branches missed.">            propType.equals(Double.TYPE) || propType.equals(Double.class)) {</span>
<span class="fc" id="L452">            return new Double(rs.getDouble(index));</span>

<span class="fc" id="L454">        } else if (</span>
<span class="pc bpc" id="L455" title="2 of 4 branches missed.">            propType.equals(Float.TYPE) || propType.equals(Float.class)) {</span>
<span class="nc" id="L456">            return new Float(rs.getFloat(index));</span>

<span class="fc" id="L458">        } else if (</span>
<span class="pc bpc" id="L459" title="2 of 4 branches missed.">            propType.equals(Short.TYPE) || propType.equals(Short.class)) {</span>
<span class="nc" id="L460">            return new Short(rs.getShort(index));</span>

<span class="pc bpc" id="L462" title="2 of 4 branches missed.">        } else if (propType.equals(Byte.TYPE) || propType.equals(Byte.class)) {</span>
<span class="nc" id="L463">            return new Byte(rs.getByte(index));</span>
            
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">        } else if (propType.equals(Timestamp.class)) {</span>
<span class="nc" id="L466">            return rs.getTimestamp(index);</span>

        } else {
<span class="fc" id="L469">            return rs.getObject(index);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>